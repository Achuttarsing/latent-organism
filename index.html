<!doctype html>
<html>
    <head>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/94/three.js" integrity="sha512-2qL88PDKCTKudKanf/i4m0b8hsfbzWEuSghP5A1IRm6JfKYtu6TtNUu0DRZNkhxc6U3kI4vYh9lk7tf6B8silA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.4/socket.io.js" integrity="sha512-c4FE2uNeKCAtchLEpO9yimL8CuifrlEMnORyTNw0TAkGqYpqADT8qX/DG/ASy+F29KUSgEgrPidbNPENW17QFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> 
        <script src=" https://cdn.rawgit.com/josephg/noisejs/master/perlin.js" crossorigin="anonymous" ></script>
        <script src=" https://cdn.rawgit.com/jeromeetienne/threex.bubble/blob/master/examples/vendor/three.js/examples/js/shaders/FresnelShader.js" crossorigin="anonymous" ></script>
    </head>
    <body>
        
        <div id="sample"></div>
        <script>
        
        
            // ------------------------------------------------
            // BASIC SETUP
            // ------------------------------------------------
            
            
            var socket = io();
            var arduino = 0
            var twisting = -1
            var blobing = -1
            // Create an empty scene
            var scene = new THREE.Scene();
            // Create a basic perspective camera
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;
            // Create a renderer with Antialiasing
            var renderer = new THREE.WebGLRenderer({antialias:true});
            // Configure renderer clear color
            renderer.setClearColor("#000000");
            // Configure renderer size
            renderer.setSize( window.innerWidth, window.innerHeight );
            // Append Renderer to DOM
            document.body.appendChild( renderer.domElement );
            

            
            // ------------------------------------------------
            // FUN STARTS HERE
            // ------------------------------------------------
            // Create a Cube Mesh with basic material
            const geometry = new THREE.BoxGeometry(20, 20, 20, 20, 20, 20); 
            const material = new THREE.MeshNormalMaterial({ wireframe: false } ); // 
            const cube = new THREE.Mesh(geometry, material); 
            scene.add(cube);
            
            
            
            // MORPHO BLOB
            
            
            var peaking = 0.1
            var emancipacing = 1
            var mandaring = 0
            var kx = 3
            var ky = 3
            var seuil_trigg = 600
            
            var blob = function() {

                var k = 3;
                    var time = performance.now() * 0.0005;
                for (var i = 0; i < cube.geometry.faces.length; i++) {
                    var uv = cube.geometry.faceVertexUvs[0][i]; //faceVertexUvs is a huge arrayed stored inside of another array
                    var f = cube.geometry.faces[i];
                    var p = cube.geometry.vertices[f.a];//take the first vertex from each face
                    //console.log('niose '+noise.perlin3(uv[0].x*k, uv[0].y*k, time))
                    
                    p.normalize().multiplyScalar(emancipacing+peaking*noise.perlin3(uv[0].x*k, uv[0].y*k, time)); // enlever pour pico 1 + 0.3
                    // effet expansif picos
                    //p.add(p.clone().normalize().multiplyScalar(0.1 * noise.perlin3(p.x * k, p.y * k, p.z * k)));
                }



                cube.geometry.verticesNeedUpdate = true; 
                cube.geometry.normalsNeedUpdate = true;
                // ajouter la texture effet 3D map
                cube.geometry.computeVertexNormals();
                cube.geometry.normalsNeedUpdate = true;

            }
            
            var mandariane = function(kx, ky) {

                //var k = 3;
                    var time = performance.now() * 0.0005;
                for (var i = 0; i < cube.geometry.faces.length; i++) {
                    var uv = cube.geometry.faceVertexUvs[0][i]; //faceVertexUvs is a huge arrayed stored inside of another array
                    var f = cube.geometry.faces[i];
                    var p = cube.geometry.vertices[f.a];//take the first vertex from each face
                    //console.log('niose '+noise.perlin3(uv[0].x*k, uv[0].y*k, time))
                    
                    p.normalize().multiplyScalar(emancipacing+peaking*noise.perlin3(uv[0].x*kx, uv[0].y*ky, time)); // enlever pour pico 1 + 0.3
                    // effet expansif picos
                    //p.add(p.clone().normalize().multiplyScalar(0.1 * noise.perlin3(p.x * k, p.y * k, p.z * k)));
                }



                cube.geometry.verticesNeedUpdate = true; 
                cube.geometry.normalsNeedUpdate = true;
                // ajouter la texture effet 3D map
                cube.geometry.computeVertexNormals();
                cube.geometry.normalsNeedUpdate = true;

            }

            
            // FLEXION : TWIST()
            const quaternion = new THREE.Quaternion(); 
            quaternion.setFromAxisAngle( 
              new THREE.Vector3(0, 1, 0), 
              Math.PI / 2 
            );  
            const vector = new THREE.Vector3(1, 0, 0); 
            vector.applyQuaternion(quaternion);
            var twist_right = function(geometry) {
              const quaternion = new THREE.Quaternion();
              for (let i = 0; i < geometry.vertices.length; i++) {
                // a single vertex Y position
                const yPos = geometry.vertices[i].y;
                const twistAmount = 2;
                const upVec = new THREE.Vector3(0, 1, 0);
                quaternion.setFromAxisAngle(upVec, (Math.PI / 180) * (yPos / twistAmount));
                geometry.vertices[i].applyQuaternion(quaternion);
              }
              // tells Three.js to re-render this mesh
              geometry.verticesNeedUpdate = true;
            }
            var twist_left = function(geometry) {
                  const quaternion = new THREE.Quaternion();
                  for (let i = 0; i < geometry.vertices.length; i++) {
                    // a single vertex Y position
                    const yPos = geometry.vertices[i].y;
                    const twistAmount = 2;
                    const upVec = new THREE.Vector3(0, 1, 0);
                    quaternion.setFromAxisAngle(upVec, (-Math.PI / 180) * (yPos / twistAmount));
                    geometry.vertices[i].applyQuaternion(quaternion);
                  }
                  // tells Three.js to re-render this mesh
                  geometry.verticesNeedUpdate = true;
                }
            console.log(geometry)
            
            /////////////////////////////////////////// RENDER LOOP ///////////////////////////////////////////
            var render = function () {
                
              requestAnimationFrame( render );
              if(twisting == 0){
                  twist_right(geometry)
              } else if (twisting == 1) {
                  twist_left(geometry)
              }
              if (blobing == 1) {
                blob();
              }
              if (mandaring == 1) {
                  mandariane(kx,ky);
                }
              cube.rotation.y += 0.005
              renderer.render(scene, camera);
            };
            
            blob(kx,ky);
            render();
            
            socket.on('arduino', function(data) {
                
                arduino = eval(data)
                //console.log('ppp'+peaking)
                //console.log('ppp'+emancipacing)
                //console.log(arduino)
                //cube.rotation.x += arduino
                var flag = false
                if (arduino[1] < seuil_trigg) {
                    //console.log('turn')
                    twisting = 0
                    flag = true
                } 
                if (arduino[2] < seuil_trigg) {
                    //console.log('turn')
                    mandaring = 1
                    emancipacing += 0.01
                    peaking += 0.1
                    kx += 2
                    //twisting = 1
                    flag = true
                } 
                if (arduino[0] < seuil_trigg) {
                    //console.log('blob')
                    blobing = 1
                    peaking += 0.1
                    emancipacing += 0.03
                    flag = true
                } 
                
                if(flag==false) {
                    twisting = -1
                    emancipacing = Math.max(emancipacing-0.01, 1);
                    //blobing = -1
                    peaking = Math.max(peaking-0.01, 0.1);
                    kx = Math.max(kx-0.1, 3);
                }
                
                
                //console.log(arduino);
                    
            });
            // socket.on('user_position', function(data) {
            //     
            //     pos = eval(data)
            //     //console.log(pos[0]-0.5);
            //     if(pos[0]-0.5 > 0){
            //         cube.translateX(0.1);
            //         console.log("gauche")
            //     } else {
            //         cube.translateX(-0.1);
            //         console.log("droite")
            //     }
            //     
            // });
        </script>
    </body>
</html>
